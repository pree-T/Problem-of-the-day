Intuition:
So basically we need to find the files with same content.
So we can use a hash table to store the content and the file name. Then we can find the files with same content.

Approach:

So we scan the paths and store the content and the file name in the hash table.
Then we can find the files with same content.
We can use the stringstream to split the string.
We can use the find function to find the position of the character.
We can use the substr function to get the substring.
C++:

class Solution {
public:
    vector<vector<string>> findDuplicate(vector<string>& paths) {
        unordered_map<string, vector<string>> hash;
        for (auto path : paths) {
            stringstream ss(path);
            string dir;
            string file;
            getline(ss, dir, ' ');
            while (getline(ss, file, ' ')) {
                string content = file.substr(file.find('(') + 1, file.find(')') - file.find('(') - 1);
                string name = dir + '/' + file.substr(0, file.find('('));
                hash[content].push_back(name);
            }
        }
        vector<vector<string>> res;
        for (auto it = hash.begin(); it != hash.end(); it++) {
            if (it->second.size() > 1) {
                res.push_back(it->second);
            }
        }
        return res;
    }
};
Time Complexity: O(n*m), where n: number of paths, m: average length of file name
Space Complexity: O(n*m)
